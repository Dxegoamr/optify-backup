var E=Object.defineProperty;var f=(s,e,a)=>e in s?E(s,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):s[e]=a;var S=(s,e,a)=>f(s,typeof e!="symbol"?e+"":e,a);import{e as u,s as d,h,f as p,u as y,q as w,t as D,x as F,z as U,H as $}from"./firebase-vendor-Dsl9zeYT.js";import{d as n}from"./index-CGNlKej4.js";class l{static async saveToUserSubcollection(e,a,r,t){try{const o=u(n,this.usersCollection,e,a,r),c={...t,createdAt:d(),updatedAt:d()};await h(o,c)}catch(o){throw console.error(`Erro ao salvar em ${a}:`,o),new Error(`Falha ao salvar dados em ${a}`)}}static async getFromUserSubcollection(e,a,r){try{const t=u(n,this.usersCollection,e,a,r),o=await p(t);if(o.exists()){const c=o.data();return{...c,createdAt:c.createdAt?.toDate()||new Date,updatedAt:c.updatedAt?.toDate()||new Date}}return null}catch(t){throw console.error(`Erro ao buscar de ${a}:`,t),new Error(`Falha ao buscar dados de ${a}`)}}static async updateUserSubcollection(e,a,r,t){try{const o=u(n,this.usersCollection,e,a,r),c=Object.fromEntries(Object.entries(t).filter(([O,A])=>A!==void 0));(await p(o)).exists()?await y(o,{...c,updatedAt:d()}):await h(o,{...c,createdAt:d(),updatedAt:d()})}catch(o){throw console.error(`Erro ao atualizar ${a}:`,o),new Error(`Falha ao atualizar dados de ${a}`)}}static async getAllFromUserSubcollection(e,a,r=[]){try{const t=w(n,this.usersCollection,e,a),o=D(t,...r);return(await F(o)).docs.map(i=>({id:i.id,...i.data(),createdAt:i.data().createdAt?.toDate()||new Date,updatedAt:i.data().updatedAt?.toDate()||new Date}))}catch(t){throw console.error(`Erro ao buscar todos de ${a}:`,t),new Error(`Falha ao buscar dados de ${a}`)}}static async addToUserSubcollection(e,a,r){try{console.log(`UserSubcollectionsService.addToUserSubcollection - salvando em ${a}:`,{userId:e,data:r});const t=w(n,this.usersCollection,e,a),o={...r,createdAt:d(),updatedAt:d()};console.log("Dados com timestamps:",o);const c=await U(t,o);return console.log(`Documento criado com ID: ${c.id}`),c.id}catch(t){throw console.error(`Erro ao adicionar em ${a}:`,t),new Error(`Falha ao adicionar dados em ${a}`)}}static async deleteFromUserSubcollection(e,a,r){try{const t=u(n,this.usersCollection,e,a,r);await $(t)}catch(t){throw console.error(`Erro ao deletar de ${a}:`,t),new Error(`Falha ao deletar dados de ${a}`)}}}S(l,"usersCollection","users");const m={PROFILE:"profile",CONFIG:"config",EMPLOYEES:"employees",PLATFORMS:"platforms",TRANSACTIONS:"transactions",DAILY_SUMMARIES:"dailySummaries",ACCOUNTS:"accounts",PAYMENTS:"payments",GOALS:"goals",REPORTS:"reports"};async function T(s){const e=Object.values(m);for(const a of e)try{a===m.PROFILE?await l.deleteFromUserSubcollection(s,a,"basic"):a===m.CONFIG&&await l.deleteFromUserSubcollection(s,a,"initial");const r=await l.getAllFromUserSubcollection(s,a);await Promise.all(r.map(t=>t?.id?l.deleteFromUserSubcollection(s,a,t.id):Promise.resolve()))}catch(r){console.warn(`Falha parcial ao deletar subcoleção ${a} do usuário ${s}:`,r)}}export{l as U,m as a,T as d};
